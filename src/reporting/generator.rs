//! Report generator implementation using templates

use crate::core::{AnalysisResult, AnalyzerError, Result};
use crate::reporting::templates::{get_report_template, ReportTemplateData};
use crate::reporting::{ReportFormat, Reporter};
use handlebars::Handlebars;
use std::path::Path;

/// Main report generator
pub struct ReportGenerator {
    handlebars: Handlebars<'static>,
}

impl ReportGenerator {
    pub fn new() -> Self {
        let mut handlebars = Handlebars::new();

        // Load embedded template
        let template_str = get_report_template();
        handlebars
            .register_template_string("report", template_str)
            .expect("Template should be valid");

        Self { handlebars }
    }

    /// Generate JSON report optimized for CI/CD
    async fn generate_json_report(&self, result: &AnalysisResult) -> Result<String> {
        // Create a CI/CD optimized JSON structure
        let ci_report = serde_json::json!({
            "session_id": result.session_id,
            "status": "success",
            "metadata": {
                "product_name": result.metadata.product_name,
                "product_version": result.metadata.product_version,
                "manufacturer": result.metadata.manufacturer,
                "format": result.metadata.format,
                "file_size": result.metadata.file_size,
                "file_hash": result.metadata.file_hash
            },
            "summary": {
                "total_files": result.files.len(),
                "executable_files": result.files.iter().filter(|f| f.attributes.executable).count(),
                "registry_operations": result.registry_operations.len(),
                "file_operations": result.file_operations.len(),
                "process_operations": result.process_operations.len(),
                "network_operations": result.network_operations.len(),
                "analysis_duration_seconds": result.analysis_duration.as_secs(),
                "dynamic_analysis": result.dynamic_analysis
            },
            "security": {
                "risk_level": self.calculate_risk_level(result),
                "executable_count": result.files.iter().filter(|f| f.attributes.executable).count(),
                "large_files_count": result.files.iter().filter(|f| f.size > 50 * 1024 * 1024).count(),
                "registry_modifications": result.registry_operations.len()
            },
            "files": result.files.iter().take(100).map(|f| serde_json::json!({
                "path": f.path,
                "size": f.size,
                "executable": f.attributes.executable,
                "compression": f.compression
            })).collect::<Vec<_>>(),
            "registry_operations": result.registry_operations.iter().take(50).collect::<Vec<_>>(),
            "analyzed_at": result.analyzed_at,
            "version": env!("CARGO_PKG_VERSION")
        });

        serde_json::to_string_pretty(&ci_report).map_err(|e| AnalyzerError::SerializationError(e))
    }

    /// Generate modern HTML report using templates
    async fn generate_html_report(&self, result: &AnalysisResult) -> Result<String> {
        let template_data = ReportTemplateData::from_analysis_result(result);

        self.handlebars
            .render("report", &template_data)
            .map_err(|e| AnalyzerError::generic(format!("Template rendering failed: {}", e)))
    }

    /// Generate Markdown report
    async fn generate_markdown_report(&self, result: &AnalysisResult) -> Result<String> {
        let markdown = format!(
            r#"# Installer Analysis Report

**Session ID:** {}
**Analyzed at:** {}
**Analysis Duration:** {}
**Dynamic Analysis:** {}

## Installer Metadata

- **Format:** {:?}
- **Product Name:** {}
- **Product Version:** {}
- **Manufacturer:** {}
- **File Size:** {}
- **File Hash:** {}

## Summary

- **Files:** {} entries
- **Registry Operations:** {} operations
- **File Operations:** {} operations
- **Process Operations:** {} operations
- **Network Operations:** {} operations

## Security Analysis

- **Risk Level:** {}
- **Executable Files:** {}
- **Large Files (>50MB):** {}

## File Analysis

### Top 10 Largest Files

{}

### Executable Files

{}

## Registry Operations

{}

---

*Report generated by Installer Analyzer v{} at {}*
"#,
            result.session_id,
            result.analyzed_at.format("%Y-%m-%d %H:%M:%S UTC"),
            crate::utils::format_duration(result.analysis_duration),
            if result.dynamic_analysis { "Yes" } else { "No" },
            result.metadata.format,
            result.metadata.product_name.as_deref().unwrap_or("Unknown"),
            result
                .metadata
                .product_version
                .as_deref()
                .unwrap_or("Unknown"),
            result.metadata.manufacturer.as_deref().unwrap_or("Unknown"),
            crate::utils::format_file_size(result.metadata.file_size),
            &result.metadata.file_hash[..16],
            result.files.len(),
            result.registry_operations.len(),
            result.file_operations.len(),
            result.process_operations.len(),
            result.network_operations.len(),
            self.calculate_risk_level(result),
            result
                .files
                .iter()
                .filter(|f| f.attributes.executable)
                .count(),
            result
                .files
                .iter()
                .filter(|f| f.size > 50 * 1024 * 1024)
                .count(),
            self.generate_top_files_markdown(&result.files),
            self.generate_executable_files_markdown(&result.files),
            self.generate_registry_operations_markdown(&result.registry_operations),
            env!("CARGO_PKG_VERSION"),
            result.analyzed_at.format("%Y-%m-%d %H:%M:%S UTC")
        );

        Ok(markdown)
    }

    /// Calculate risk level for CI/CD
    fn calculate_risk_level(&self, result: &AnalysisResult) -> String {
        let executable_count = result
            .files
            .iter()
            .filter(|f| f.attributes.executable)
            .count();
        let large_files = result
            .files
            .iter()
            .filter(|f| f.size > 50 * 1024 * 1024)
            .count();

        if executable_count > 10 || large_files > 5 {
            "high".to_string()
        } else if executable_count > 5 || large_files > 2 {
            "medium".to_string()
        } else {
            "low".to_string()
        }
    }

    /// Generate top files section for markdown
    fn generate_top_files_markdown(&self, files: &[crate::core::FileEntry]) -> String {
        let mut sorted_files: Vec<_> = files.iter().collect();
        sorted_files.sort_by(|a, b| b.size.cmp(&a.size));

        let mut markdown = String::new();
        for (i, file) in sorted_files.iter().take(10).enumerate() {
            markdown.push_str(&format!(
                "{}. **{}** - {}\n",
                i + 1,
                file.path.file_name().unwrap_or_default().to_string_lossy(),
                crate::utils::format_file_size(file.size)
            ));
        }

        if markdown.is_empty() {
            markdown.push_str("No files found.\n");
        }

        markdown
    }

    /// Generate executable files section for markdown
    fn generate_executable_files_markdown(&self, files: &[crate::core::FileEntry]) -> String {
        let executable_files: Vec<_> = files.iter().filter(|f| f.attributes.executable).collect();

        let mut markdown = String::new();
        for file in executable_files.iter().take(20) {
            markdown.push_str(&format!(
                "- **{}** - {}\n",
                file.path.file_name().unwrap_or_default().to_string_lossy(),
                crate::utils::format_file_size(file.size)
            ));
        }

        if markdown.is_empty() {
            markdown.push_str("No executable files found.\n");
        }

        markdown
    }

    /// Generate registry operations section for markdown
    fn generate_registry_operations_markdown(
        &self,
        operations: &[crate::core::RegistryOperation],
    ) -> String {
        let mut markdown = String::new();

        for (i, op) in operations.iter().take(20).enumerate() {
            match op {
                crate::core::RegistryOperation::CreateKey { key_path, .. } => {
                    markdown.push_str(&format!("{}. **Create Key:** `{}`\n", i + 1, key_path));
                }
                crate::core::RegistryOperation::SetValue {
                    key_path,
                    value_name,
                    ..
                } => {
                    markdown.push_str(&format!(
                        "{}. **Set Value:** `{}\\{}`\n",
                        i + 1,
                        key_path,
                        value_name
                    ));
                }
                crate::core::RegistryOperation::DeleteKey { key_path, .. } => {
                    markdown.push_str(&format!("{}. **Delete Key:** `{}`\n", i + 1, key_path));
                }
                crate::core::RegistryOperation::DeleteValue {
                    key_path,
                    value_name,
                    ..
                } => {
                    markdown.push_str(&format!(
                        "{}. **Delete Value:** `{}\\{}`\n",
                        i + 1,
                        key_path,
                        value_name
                    ));
                }
            }
        }

        if markdown.is_empty() {
            markdown.push_str("No registry operations found.\n");
        }

        markdown
    }
}

impl Reporter for ReportGenerator {
    async fn generate_report(
        &self,
        result: &AnalysisResult,
        format: ReportFormat,
    ) -> Result<String> {
        match format {
            ReportFormat::Json => self.generate_json_report(result).await,
            ReportFormat::Html => self.generate_html_report(result).await,
            ReportFormat::Markdown => self.generate_markdown_report(result).await,
        }
    }

    async fn save_report(
        &self,
        result: &AnalysisResult,
        format: ReportFormat,
        output_path: &Path,
    ) -> Result<()> {
        let content = self.generate_report(result, format).await?;
        tokio::fs::write(output_path, content).await?;
        tracing::info!("Report saved to: {}", output_path.display());
        Ok(())
    }
}

impl Default for ReportGenerator {
    fn default() -> Self {
        Self::new()
    }
}
